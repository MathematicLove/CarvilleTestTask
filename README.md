# Carville $_{тестовое \space задание}$
### Метод решения:
- Мат. описание $\rightarrow$ программная реализация
    - так как это более математическая задача.
### Стек:
- ОС: UNIX (macOS) (лучше запустить проект с docker)
- Язык программирования
    - Python
- Развёртывание
    - Docker
    - docker-compose.yml
- Тестирование
    - Unittest
- Библиотеки    
    - стандартные библиотеки python 
        - `decimal` 
        - `math`
        - `unittest`
- VC
    - Git
### Выдоча проекта
    - Ссылка на проект с открытым репозиторием (GitHub)
    - Архив проекта 
        - cli.py
        - nds.py
        - test.py
        - README.md
        - Dockerfile
        - docker-compose.yml 
    

## Запуск проекта 
### docker-compose

```bash
docker compose up --build nds-calc
# тут можно менять значения
docker compose run --rm nds-calc 1.81 18 mod
# тесты
docker compose run --rm tests

docker build -t nds-calc .
docker run --rm nds-calc 1.81 20

docker run --rm --entrypoint python nds-calc nds.py
```

### Colima docker (если macOS > 14)
```zsh
docker-compose up --build nds-calc
docker-compose run --rm nds-calc 1.81 18 optimal
docker-compose run --rm tests
```

### python (terminal)
```bash
    python nds.py
    python cli.py 1.81 20
    python cli.py 1.81 18 mod

    # тесты
    python -m unittest tests.py -v
```

# Решение

**Данные:**
- Рекомендованная цена с НДС `InputPriceWithNDS = P` (до 20 знаков после запятой).
- Процент НДС `ProcNDS = p`, целое `0..99`.

**Выходные данные:**
- Найти пару цен с точностью до копеек т.е 2 знака после точки:  
  `CorrectedPriceWithNDS = W` и `CorrectedPriceWithoutNDS = U` (ровно 2 знака),  
  чтобы выполнялось точное равенство без округлений:
  $$
  W = U \cdot \left(1 + \frac{p}{100}\right)
  $$
- И чтобы $| W - P |$ было минимально среди всех таких пар.  
  При равной близости выбираем меньшую цену с НДС (тай-брейк «вниз»).

## Реализованные варинты

В `nds.py` реализованы 4 алгоритма. По O-нотации:

1. **Оптимальный (O(1)) — `calc_prices` / `calc`**  
   Вычисляет шаг допустимых цен с НДС в копейках, находит ближайший элемент к целевому `P*100` — без циклов, то есть будет точно меньше квадрата.
2. **Через модуль (O(1)) — `calc_prices_via_mod`**  
   Та же идея, но запись через остаток по модулю шага.
3. **Бинарный поиск (O(log)) — `calc_prices_binary_search`**  
   Ищем индекс ближайшего элемента прогрессии. Но этот алгоритм сложнее в плане O-нотации...
4. **Локальный перебор (O(window)) — `calc_prices_bruteforce_window`**  
   Проверяем небольшое окно соседних кандидатов вокруг ближайшего индекса.
5. **NP-полное решение** - сразу нет, так как выйдет факториальная сложность N!.

**Почему выбран оптимальный:**  
- Константное время и память, потому что без циклов и переборов.  
- Абсолютная точность на 2 знаках без округлений.  
- Надёжность на входах с 20 знаками после запятой за счёт потому и использовал `decimal.Decimal`.

## Алгоритмическое и математическое описание

Работаем в копейках (целых числах). 

Пусть:
- $U$ — цена без НДС в копейках (целое).
- $W$ — цена с НДС в копейках (целое).
- $p$ — ставка НДС (целое $0..99$).
- $P$ — входная цена с НДС (в рублях, до 20 знаков).
- $T = 100 \cdot P$ — целевое значение в копейках (может быть нецелым).

Формальное равенство:
$$
W = U \cdot \frac{100 + p}{100}.
$$

Чтобы $W$ было целым, необходимо и достаточно, чтобы
$$
100 \mid U \cdot (100 + p).
$$

Пусть $g = \gcd(100,\, 100 + p)$, где (gcd - наибольший общий делитель)

$\Rightarrow$

$$
U \text { кратен } \frac{100}{g}.
$$
$\Rightarrow$ допустимые $W$ образуют арифметическую прогрессию с шагом s:
$$
s = \frac{100 + p}{g} \quad \text{(в копейках)}.
$$
То есть множество допустимых $W$:
$$
\{\, 0,\, s,\, 2s,\, 3s,\, \dots \,\}.
$$

Тогда нужно выбрать $W$ из этой прогрессии, ближайший к $T=100P$:
$$
W^* = \operatorname*{arg\,min}_{W \in s\mathbb{Z}_{\ge 0}} \,\lvert W - T \rvert .
$$


Достаточно рассмотреть два соседних кандидата:
- $W_{\downarrow} = \left\lfloor \frac{T}{s} \right\rfloor \cdot s$,
- $W_{\uparrow}   = W_{\downarrow} + s$,

и взять наиболее близкий. При равенстве берём вниз.

Далее восстанавливаем $U$ (в копейках) — гарантированно целое:
$$
U^* = \frac{W^* \cdot 100}{100 + p}.
$$

Переводим оба значения в рубли делением на 100 — это точно даёт **ровно два знака**,
поскольку все деления кратны 100 и не требуют округления.

### Лучший выбор:
- **O(1) по времени и памяти**: нет переборов, поиск сводится к двум кандидатам.
- **Точность**: работаем только с целыми копейками и `Decimal`, поэтому никаких двоичных погрешностей и округлений.
- **Корректность и мат. описание**: условия кратности через $\gcd$ гарантируют, что восстановленный $U^*$ целый, а равенство $W^* = U^*(1 + p/100)$ выполняется точно в копейках. Что показано математически.

## Псевдокод
```txt
input: P(Decimal), p(int 0..99)
output: Tuple<Decimal, Decimal> //Цена с НДС, без НДС 

Begin:

T := P * 100;
g := gcd(100, 100 + p);
s := (100 + p) / g;

k := floor(T / s);
W1 := k * s;
W2 := W1 + s;

if | W2 - T | < | T - W1 | { 
    W := W2;
} 
else if (| W2 - T | == | T - W1 | && tie = "up") {
    W := W2;
} 
else {
    W := W1;
}

U := (W * 100) / (100 / p);

Output: (W/100, U/100)

End;
```